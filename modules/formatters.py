"""Output formatters for Journal LLM summaries."""

import json
from abc import ABC, abstractmethod
from typing import Dict, List, Optional
from datetime import datetime
from pathlib import Path
from modules.logger import get_logger

logger = get_logger(__name__)


class OutputFormatter(ABC):
    """Abstract base class for output formatters."""
    
    @abstractmethod
    def format(self, data: Dict) -> str:
        """Format the summary data.
        
        Args:
            data: Dictionary containing title, summary, key_points, and action_items
            
        Returns:
            Formatted string representation
        """
        pass
    
    def save_to_file(self, data: Dict, filepath: str) -> None:
        """Save formatted output to a file.
        
        Args:
            data: Summary data to format
            filepath: Path to save the output
        """
        formatted = self.format(data)
        path = Path(filepath)
        
        # Create parent directories if they don't exist
        path.parent.mkdir(parents=True, exist_ok=True)
        
        try:
            with open(path, 'w', encoding='utf-8') as f:
                f.write(formatted)
            logger.info(f"Output saved to: {path}")
        except IOError as e:
            logger.error(f"Failed to save output to {filepath}: {str(e)}")
            raise


class PlainTextFormatter(OutputFormatter):
    """Format output as plain text."""
    
    def format(self, data: Dict) -> str:
        """Format as plain text with simple separators."""
        lines = []
        
        # Title section
        lines.append("=" * 50)
        lines.append(f"TITLE: {data.get('title', 'Untitled')}")
        lines.append("=" * 50)
        
        # Summary section
        lines.append("")
        lines.append("SUMMARY:")
        lines.append(data.get('summary', 'No summary available'))
        
        # Key points section
        lines.append("")
        lines.append("KEY POINTS:")
        key_points = data.get('key_points', [])
        if key_points:
            for point in key_points:
                lines.append(f"  • {point}")
        else:
            lines.append("  • No key points identified")
        
        # Action items section
        lines.append("")
        lines.append("ACTION ITEMS:")
        action_items = data.get('action_items', [])
        if action_items:
            for item in action_items:
                lines.append(f"  □ {item}")
        else:
            lines.append("  □ No action items identified")
        
        lines.append("=" * 50)
        return "\n".join(lines)


class MarkdownFormatter(OutputFormatter):
    """Format output as Markdown."""
    
    def format(self, data: Dict) -> str:
        """Format as Markdown with proper headers and lists."""
        lines = []
        
        # Title as H1
        lines.append(f"# {data.get('title', 'Untitled')}")
        lines.append("")
        
        # Metadata
        lines.append(f"*Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*")
        lines.append("")
        lines.append("---")
        lines.append("")
        
        # Summary as section
        lines.append("## Summary")
        lines.append("")
        lines.append(data.get('summary', 'No summary available'))
        lines.append("")
        
        # Key points as bullet list
        lines.append("## Key Points")
        lines.append("")
        key_points = data.get('key_points', [])
        if key_points:
            for point in key_points:
                # Clean up the point - remove leading dashes if present
                clean_point = point.lstrip('- ')
                lines.append(f"- {clean_point}")
        else:
            lines.append("*No key points identified*")
        lines.append("")
        
        # Action items as task list
        lines.append("## Action Items")
        lines.append("")
        action_items = data.get('action_items', [])
        if action_items:
            for item in action_items:
                clean_item = item.lstrip('- ')
                lines.append(f"- [ ] {clean_item}")
        else:
            lines.append("*No action items identified*")
        lines.append("")
        
        # Footer
        lines.append("---")
        lines.append("*Generated by Journal LLM*")
        
        return "\n".join(lines)


class JSONFormatter(OutputFormatter):
    """Format output as JSON."""
    
    def format(self, data: Dict) -> str:
        """Format as pretty-printed JSON."""
        # Add metadata to the output
        output = {
            "metadata": {
                "generated_at": datetime.now().isoformat(),
                "generator": "Journal LLM"
            },
            "content": {
                "title": data.get('title', 'Untitled'),
                "summary": data.get('summary', ''),
                "key_points": data.get('key_points', []),
                "action_items": data.get('action_items', [])
            }
        }
        
        return json.dumps(output, indent=2, ensure_ascii=False)


class FormatterFactory:
    """Factory for creating output formatters."""
    
    _formatters = {
        'plain': PlainTextFormatter,
        'markdown': MarkdownFormatter,
        'json': JSONFormatter
    }
    
    @classmethod
    def create(cls, format_type: str) -> OutputFormatter:
        """Create a formatter instance.
        
        Args:
            format_type: Type of formatter ('plain', 'markdown', 'json')
            
        Returns:
            OutputFormatter instance
            
        Raises:
            ValueError: If format_type is not recognized
        """
        formatter_class = cls._formatters.get(format_type.lower())
        if not formatter_class:
            raise ValueError(f"Unknown format type: {format_type}")
        
        return formatter_class()
    
    @classmethod
    def list_formats(cls) -> List[str]:
        """Get list of available format types."""
        return list(cls._formatters.keys())